\chapter{\IfLanguageName{dutch}{Stand van zaken}{State of the art}}%
\label{ch:stand-van-zaken}

% Tip: Begin elk hoofdstuk met een paragraaf inleiding die beschrijft hoe
% dit hoofdstuk past binnen het geheel van de bachelorproef. Geef in het
% bijzonder aan wat de link is met het vorige en volgende hoofdstuk.

% Pas na deze inleidende paragraaf komt de eerste sectiehoofding.

%Dit hoofdstuk bevat je literatuurstudie. De inhoud gaat verder op de inleiding, maar zal het onderwerp van de bachelorproef *diepgaand* uitspitten. De bedoeling is dat de lezer na lezing van dit hoofdstuk helemaal op de hoogte is van de huidige stand van zaken (state-of-the-art) in het onderzoeksdomein. Iemand die niet vertrouwd is met het onderwerp, weet nu voldoende om de rest van het verhaal te kunnen volgen, zonder dat die er nog andere informatie moet over opzoeken \autocite{Pollefliet2011}.

%Je verwijst bij elke bewering die je doet, vakterm die je introduceert, enz.\ naar je bronnen. In \LaTeX{} kan dat met het commando \texttt{$\backslash${textcite\{\}}} of \texttt{$\backslash${autocite\{\}}}. Als argument van het commando geef je de ``sleutel'' van een ``record'' in een bibliografische databank in het Bib\LaTeX{}-formaat (een tekstbestand). Als je expliciet naar de auteur verwijst in de zin (narratieve referentie), gebruik je \texttt{$\backslash${}textcite\{\}}. Soms is de auteursnaam niet expliciet een onderdeel van de zin, dan gebruik je \texttt{$\backslash${}autocite\{\}} (referentie tussen haakjes). Dit gebruik je bv.~bij een citaat, of om in het bijschrift van een overgenomen afbeelding, broncode, tabel, enz. te verwijzen naar de bron. In de volgende paragraaf een voorbeeld van elk.

%\textcite{Knuth1998} schreef een van de standaardwerken over sorteer- en zoekalgoritmen. Experten zijn het erover eens dat cloud computing een interessante opportuniteit vormen, zowel voor gebruikers als voor dienstverleners op vlak van informatietechnologie~\autocite{Creeger2009}.

%Let er ook op: het \texttt{cite}-commando voor de punt, dus binnen de zin. Je verwijst meteen naar een bron in de eerste zin die erop gebaseerd is, dus niet pas op het einde van een paragraaf.

\section{Garbage Collection}
\label{sec:Garbage collection}
Geheugenbeheer is een brede onderdeel van de computerwetenschap, er is al veel onderzoek naar
Garbage Collection is het automatisch beheren van het geheugen van een programma zodanig dat alloceerde geheugen die niet meer gebruikt wordt terug opgeruimd kan worden zodanig dat er geheugen terug vrij komt.

Meeste programmeertalen maken vandaag de dag gebruik van een \textit{heap}, in het algemeen kunnen we dit voorstellen als een gerichte graaf met knopen, of \textit{objecten}, met een \textit{root} object dat als vertrekpunt gebruikt wordt.

\textit{Reference Counting} Garbage Collectors maken gebruik van een referentie teller voor elke object, dit betekend dat er per object een teller is die incrementeel stijgt voor elke referentie naar dat object.
Als de teller op 0 staat betekend dit dat er geen referenties meer zijn naar naar dat object, deze object mag dan  opgeruimd worden.
Het nadeel van deze implementatie is dat er een mogelijkheid bestaat dat 2 objecten alleen nog maar met elkaar een referentie hebben, de teller zal dan niet op 0 staan maar de objecten zijn niet meer bereikbaar voor het programma en mogen dus eigenlijk wel opgeruimd worden.
Dit wordt een \textit{dode cykel} genoemd.\autocite{VanderCruysse2019}

\textit{Tracing} Garbage Collectors werken aan de hand van een ander principe.
Knopen die vanuit de root niet meer bereikbaar zijn kunnen ook niet meer door het programma gebruikt worden, het is niet alleen onnodig dat deze knopen nog blijven bestaan, maar zelfs nadelig aangezien zij wel nog steeds geheugen gebruiken.
Onbereikbare objecten, worden 'dood' genoemd, knopen die nog steeds bereikbaar zijn worden 'levend' genoemd.
Tracing Garbage Collectors gaan dus te werk door alle objecten die niet bereikbaar zijn vanuit de root te vinden. 

Binnen de Tracing Garbage Collectors zijn er verschillende manieren, of algoritmes, om te bepalen welke delen van het geheugen opgeruimd mogen worden.
De voornaamste zijn namelijk;
    \subsection{Mark/Sweep}
    
    
    Deze Garbage Collection algoritme wordt door Java gebruikt, de exacte implementatie ervan in Java zal verder in de literatuurstudie dieper beschreven worden.
    %TODO \subsection{title}
    
    
\section{Java geheugenbeheer}
\label{sec:java geheugenbeheer}
Vooraleer we de implementatie van Garbage Collection in Java bespreken, is het noodzakelijk om een goed beeld te krijgen hoe Java het geheugengebruik beheert.
Java code wordt gecompileerd naar een .class file, deze bestaat uit '\textit{bytecode}', deze wordt geïnterpreteerd door de '\textit{Java Virtual Machine}' en omgevormd naar \textit{machine code}, dit is code die de processor kan interpreteren en uitvoeren.

De JVM zorgt ook voor het beheer van het geheugengebruik, de \textit{runtime data area} is een onderdeel van de .class file, die de JVM gebruikt om geheugen te beheren die nodig is voor klassen data, geheugen toekenning, en uit te voeren instructies.\autocite{Putten2022}
Er zijn voornamelijk 3 onderdelen van deze runtime data area;

    \subsection{Stack}
    \label{sec:Stack}
    
    De stack houdt oftewel een primitieve variabele vast, of een referentie.
    Een primitieve variabele kan bijvoorbeeld een \textit{integer} zijn met een bepaalde numerieke waarde.
    Een referentie is een pointer naar een bepaalde \textit{memory address}, dit komt overeen met een fysieke locatie in het geheugen.\autocite{Huck1993}
    Er zijn 4 soorten referenties, namelijk;
    \begin{enumerate}
        \item Klasse referenties
        \item Array referenties
        \item Interface referenties
        \item Null
    \end{enumerate}
    Klasse referenties houden een verwijzing naar de adres van een object op de heap geheugen, objecten worden in de heap geheugen opgeslagen.
    Array referenties verwijzen naar arrays
    Wanneer een referentie null is betekent het dat de referentie naar niets meer verwijst.
    %Per thread wordt er een stack gecreëerd !!TODO!! %TODO
    
    %https://jcp.org/aboutJava/communityprocess/maintenance/jsr924/JVMS-SE5.0-Ch3-Overview.pdf
    %TODO Hoe in bibliografie zetten?
    \subsection{Heap}
    \label{sec:heap}
    Volgens \textcite{Grgic2018} wordt de heap aangemaakt door de JVM bij het opstarten van de Java programma, de heap heeft geheugenposities die gebruikt worden om geheugen toe te wijzen aan arrays en instanties van klassen, ook bekend als objecten.
    Alsook kan een geheugenpositie in de heap leeg zijn.
    
    De heap is een array van geheugen posities die oftewel niets oftewel een object bevatten.
    Een object is een aaneengesloten reeks van geheugenposities, het wordt zelf onderverdeeld in velden die een primitieve type kunnen bevatten of een referentie.
    Deze referentie kan een pointer zijn naar een ander object in de heap geheugen, of null zijn.\autocite{Bruno2018}
    \subsection{Metaspace}
    \label{sec:Metaspace}
    De Metaspace bevat metadata over klassen.
    Wanneer er een object wordt aangemaakt waarvan er nog geen objecten van die klasse bestaan, moet er metadata over de klasse voorzien worden in de Metaspace, de Class Loader zorgt hiervoor.
    
    De Class Loader is een object in de heap, deze bevat referenties naar de metadata over de klasse, deze metadata bindt zich in de Metaspace geheugen.
    Er is niet maar 1 Class Loader, er bestaan verschillende Class Loaders, de bootstrap class loader voor andere class loaders aan te maken, en de applicatie class loader voor de root klasse van de applicatie, deze houden metadata die permanent in de Metaspace verblijft.
    
    Verder zijn er nog Dynamische class loaders, zij zorgen voor de metadata van klassen van objecten die door het programma gecreëerd worden, de metadata hiervan verblijft niet noodzakelijk permanent in de Metaspace.
    \autocite{Putten2022}
    \subsection{Garbage Collection}
    \label{sec:garbage collection}
    Garbage Collection in Java bevrijdt geheugen uit zowel de heap als Metaspace.
    Wanneer een object in de heap bestaat maar er geen verwijzingen meer naar toe zijn in de stack geheugen wordt het object als 'dood' beschouwd, het mag verwijderd worden zodanig dat het verbruikte geheugen terug vrij komt.
    Als er geen objecten meer bestaan in de heap waarvan de Object Loader referenties naar de klasse metadata in de metaspace bezit, kan de Object Loader ook uit de heap verwijdert worden.
    Indien dit zo is, zijn er klasse metadata in de metaspace waar er geen Object Loaders naar toe verwijzen, deze kunnen dan ook opgeruimd worden. \autocite{Putten2022}
    
    Garbage collectors bepalen wat 'levend' en wat 'dood' is door vanuit de stack vertrekkende een pad te banen naar alle referentie %TODO
    al hetgeen dat niet gemarkeerd is mag opgeruimd worden aangezien het programma er niet maar aan kan, en het dus geen nut meer heeft om verder te bestaan.
    %TODO: pg 60 in Putten2022,  phases!!!!!!!!!!!!!!!!!!!
\section{Mainframe}
\label{sec:mainframe}
    \subsection{Mainframe introductie}
    \label{sec:mainframe introductie}
    \subsection{Java}
    \label{sec:mainframe java}
    
    \subsection{Garbage Collection}
    \label{sec:mainframe garbage collection}
